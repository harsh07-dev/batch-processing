package com.assignment.customer_batch_processor.processor;

import com.assignment.customer_batch_processor.Customer_Entity.Customer;
import com.assignment.customer_batch_processor.service.EncryptionService;
import com.assignment.customer_batch_processor.validator.CustomerValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.UUID;

/**
 * PROCESSOR COMPONENT
 * 
 * Responsibility:
 * 1. Receive Customer objects from Reader
 * 2. Validate all fields using regex patterns
 * 3. Clean and normalize data
 * 4. Encrypt sensitive data (Aadhaar & PAN)
 * 5. Generate UUID for primary key
 * 6. Filter out invalid records (return null)
 * 7. Pass valid records to Writer
 */
@Component
public class CustomerItemProcessor implements ItemProcessor<Customer, Customer> {
    
    private static final Logger logger = LoggerFactory.getLogger(CustomerItemProcessor.class);
    
    @Autowired
    private CustomerValidator customerValidator;
    
    @Autowired
    private EncryptionService encryptionService;
    
    private int processedCount = 0;
    private int validCount = 0;
    private int invalidCount = 0;
    
    @Override
    public Customer process(Customer customer) throws Exception {
        processedCount++;
        
        logger.debug("üîÑ PROCESSOR: Processing customer #{} - {}", processedCount, customer.getName());
        
        try {
            // STEP 1: Clean and normalize data
            Customer cleanedCustomer = cleanCustomerData(customer);
            
            // STEP 2: Validate all fields
            if (!validateCustomer(cleanedCustomer)) {
                invalidCount++;
                logProgress();
                return null; // Skip invalid records
            }
            
            // STEP 3: ID will be auto-generated by database (GenerationType.IDENTITY)
            // No need to set ID manually - database will handle it
            
            // STEP 4: Encrypt sensitive data
            encryptSensitiveData(cleanedCustomer);
            
            // STEP 5: Set audit timestamps (createdDate will be set in @PrePersist)
            // Just ensure the methods exist and work
            cleanedCustomer.setCreatedDate(java.time.LocalDateTime.now());
            cleanedCustomer.setUpdatedDate(null); // New record, no update date
            
            validCount++;
            logProgress();
            
            logger.debug("‚úÖ PROCESSOR: Successfully processed customer - Name: {}", 
                        cleanedCustomer.getName());
            
            return cleanedCustomer;
            
        } catch (Exception e) {
            invalidCount++;
            logger.error("‚ùå PROCESSOR: Error processing customer {}: {}", 
                        customer.getName(), e.getMessage());
            logProgress();
            return null; // Skip records with processing errors
        }
    }
    
    /**
     * STEP 1: Clean and normalize customer data
     */
    private Customer cleanCustomerData(Customer customer) {
        logger.debug("üßπ PROCESSOR: Cleaning customer data");
        
        if (customer.getName() != null) {
            customer.setName(customer.getName().trim().toUpperCase());
        }
        
        if (customer.getEmail() != null) {
            customer.setEmail(customer.getEmail().trim().toLowerCase());
        }
        
        if (customer.getPhoneNumber() != null) {
            // Remove all spaces and special characters
            customer.setPhoneNumber(customer.getPhoneNumber().trim().replaceAll("[^0-9]", ""));
        }
        
        if (customer.getAadhaarNumber() != null) {
            // Remove spaces and special characters
            customer.setAadhaarNumber(customer.getAadhaarNumber().trim().replaceAll("[^0-9]", ""));
        }
        
        if (customer.getPanNumber() != null) {
            customer.setPanNumber(customer.getPanNumber().trim().toUpperCase());
        }
        
        if (customer.getState() != null) {
            customer.setState(customer.getState().trim().toUpperCase());
        }
        
        if (customer.getCity() != null) {
            customer.setCity(customer.getCity().trim().toUpperCase());
        }
        
        return customer;
    }
    
    /**
     * STEP 2: Validate customer using regex patterns
     */
    private boolean validateCustomer(Customer customer) {
        logger.debug("‚úîÔ∏è PROCESSOR: Validating customer data");
        
        boolean isValid = customerValidator.validateCustomer(customer);
        
        if (!isValid) {
            logger.warn("‚ö†Ô∏è PROCESSOR: Invalid customer data - Name: {}, Email: {}", 
                       customer.getName(), customer.getEmail());
        }
        
        return isValid;
    }
    
    /**
     * STEP 4: Encrypt sensitive data (Aadhaar & PAN)
     */
    private void encryptSensitiveData(Customer customer) throws Exception {
        logger.debug("üîí PROCESSOR: Encrypting sensitive data");
        
        if (customer.getAadhaarNumber() != null) {
            String encryptedAadhaar = encryptionService.encrypt(customer.getAadhaarNumber());
            customer.setAadhaarNumber(encryptedAadhaar);
            logger.debug("üîê PROCESSOR: Aadhaar encrypted successfully");
        }
        
        if (customer.getPanNumber() != null) {
            String encryptedPan = encryptionService.encrypt(customer.getPanNumber());
            customer.setPanNumber(encryptedPan);
            logger.debug("üîê PROCESSOR: PAN encrypted successfully");
        }
    }
    
    /**
     * Log processing progress
     */
    private void logProgress() {
        if (processedCount % 1000 == 0) {
            logger.info("üìä PROCESSOR: Progress - Processed: {}, Valid: {}, Invalid: {}", 
                       processedCount, validCount, invalidCount);
        }
    }
    
    /**
     * Get processing statistics
     */
    public ProcessingStats getStats() {
        return new ProcessingStats(processedCount, validCount, invalidCount);
    }
    
    /**
     * Reset processor statistics
     */
    public void reset() {
        processedCount = 0;
        validCount = 0;
        invalidCount = 0;
    }
    
    /**
     * Processing statistics holder
     */
    public static class ProcessingStats {
        private final int processed;
        private final int valid;
        private final int invalid;
        
        public ProcessingStats(int processed, int valid, int invalid) {
            this.processed = processed;
            this.valid = valid;
            this.invalid = invalid;
        }
        
        public int getProcessed() { return processed; }
        public int getValid() { return valid; }
        public int getInvalid() { return invalid; }
        
        @Override
        public String toString() {
            return String.format("ProcessingStats{processed=%d, valid=%d, invalid=%d}", 
                               processed, valid, invalid);
        }
    }
}