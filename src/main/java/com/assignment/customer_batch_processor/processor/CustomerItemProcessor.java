package com.assignment.customer_batch_processor.processor;

import com.assignment.customer_batch_processor.Customer_Entity.Customer;
import com.assignment.customer_batch_processor.service.EncryptionService;
import com.assignment.customer_batch_processor.validator.CustomerValidator;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * PROCESSOR COMPONENT
 * 
 * Responsibility:
 * 1. Receive Customer objects from Reader
 * 2. Validate all fields using regex patterns
 * 3. Clean and normalize data
 * 4. Encrypt sensitive data (Aadhaar & PAN)
 * 5. Generate UUID for primary key
 * 6. Filter out invalid records (return null)
 * 7. Pass valid records to Writer
 */
@Component
@Slf4j
public class CustomerItemProcessor implements ItemProcessor<Customer, Customer> {
    
    @Autowired
    private CustomerValidator customerValidator;
    
    @Autowired
    private EncryptionService encryptionService;
    
    private int processedCount = 0;
    private int validCount = 0;
    private int invalidCount = 0;
    
    @Override
    public Customer process(Customer customer) throws Exception {
        processedCount++;
        
        log.info(" PROCESSOR: Processing customer #{} - {}", processedCount, customer.getName());
        
        try {
            // STEP 1: Clean and normalize data
            Customer cleanedCustomer = cleanAndBuildCustomer(customer);
            
            // STEP 3: ID will be auto-generated by database (GenerationType.IDENTITY)
            // No need to set ID manually - database will handle it
            
            // STEP 4: Encrypt sensitive data
            encryptSensitiveData(cleanedCustomer);
            
            // STEP 5: Set audit timestamps (createdDate will be set in @PrePersist)
            // Just ensure the methods exist and work
            cleanedCustomer.setCreatedDate(java.time.LocalDateTime.now());
            cleanedCustomer.setUpdatedDate(null); // New record, no update date
            
            validCount++;
            logProgress();
            
            log.info(" PROCESSOR: Successfully processed customer - Name: {}",
                        cleanedCustomer.getName());
            
            return cleanedCustomer;
            
        } catch (Exception e) {
            invalidCount++;
            log.error(" PROCESSOR: Error processing customer {}: {}",
                        customer.getName(), e.getMessage());
            logProgress();
            throw e; // Skip records with processing errors
        }
    }
    
    /**
     * STEP 1: Clean and normalize customer data
     */
    private Customer cleanAndBuildCustomer(Customer customer) {
        log.info(" PROCESSOR: Cleaning customer data");
        
        if (customer.getName() != null) {
            if(customerValidator.isValidName(customer.getName())) {
                customer.setName(customer.getName().trim());
            } else {
                throw new RuntimeException("Invalid name {} "+ customer.getName());
            }
        }
        
        if (customer.getEmail() != null) {
            if(customerValidator.isValidEmail(customer.getEmail())) {
                customer.setEmail(customer.getEmail().trim().toLowerCase());
            }
            else {
                throw new RuntimeException("Invalid email for name {} "+ customer.getName());
            }
        }
        
        if (customer.getPhoneNumber() != null) {
            // Remove all spaces and special characters
            if(customerValidator.isValidMobile(customer.getPhoneNumber())) {
                customer.setPhoneNumber(customer.getPhoneNumber().trim().replaceAll("[^0-9]", ""));
            }
            else {
                throw new RuntimeException("Invalid phone number for name {} "+ customer.getName());
            }
        }

        if (customer.getAadhaarNumber() != null) {
            // Remove spaces and special characters
            if(customerValidator.isValidAadhaar(customer.getAadhaarNumber())) {
                customer.setAadhaarNumber(customer.getAadhaarNumber().trim().replaceAll("[^0-9]", ""));
            }
            else {
                throw new RuntimeException("Invalid aadhar for name {} "+ customer.getName());
            }
        }
        
        if (customer.getPanNumber() != null) {
            if(customerValidator.isValidPAN(customer.getPanNumber())) {
                customer.setPanNumber(customer.getPanNumber().trim().toUpperCase());
            } else {
                throw new RuntimeException("Invalid Pan for name "+ customer.getName() + ".");
            }
        }
        
        if (customer.getState() != null) {
            if(customerValidator.isValidState(customer.getState())) {
                customer.setState(customer.getState().trim().toUpperCase());
            }
            else {
                throw new RuntimeException("Invalid state for name {} "+ customer.getName());
            }
        }
        
        if (customer.getCity() != null) {
            if(customerValidator.isValidCity(customer.getCity())) {
                customer.setCity(customer.getCity().trim().toUpperCase());
            } else {
                throw new RuntimeException("Invalid city for name {} "+ customer.getName());
            }
        }
        
        return customer;
    }
    
    /**
     * STEP 2: Validate customer using regex patterns
     */
    private boolean validateCustomer(Customer customer) throws Exception{
        log.info("PROCESSOR: Validating customer data");
        try {

            boolean isValid = customerValidator.validateCustomer(customer);

            if (!isValid) {
                String errorMessage = "Invalid customer data - Name: "
                        + customer.getName() + ", Email: " +  customer.getEmail();
                throw new RuntimeException(errorMessage);
            }

            return isValid;
        } catch (Exception e) {
            log.error("Exception in validateCustomer {} ", e.getMessage(), e);
            throw new Exception(e);
        }
    }
    
    /**
     * STEP 4: Encrypt sensitive data (Aadhaar & PAN)
     */
    private void encryptSensitiveData(Customer customer) throws Exception {
        log.info(" PROCESSOR: Encrypting sensitive data");
        
        if (customer.getAadhaarNumber() != null) {
            String encryptedAadhaar = encryptionService.encrypt(customer.getAadhaarNumber());
            customer.setAadhaarNumber(encryptedAadhaar);
            log.info(" PROCESSOR: Aadhaar encrypted successfully");
        }
        
        if (customer.getPanNumber() != null) {
            String encryptedPan = encryptionService.encrypt(customer.getPanNumber());
            customer.setPanNumber(encryptedPan);
            log.info(" PROCESSOR: PAN encrypted successfully");
        }
    }
    
    /**
     * Log processing progress
     */
    private void logProgress() {
        if (processedCount % 1000 == 0) {
            log.info(" PROCESSOR: Progress - Processed: {}, Valid: {}, Invalid: {}",
                       processedCount, validCount, invalidCount);
        }
    }
    
    /**
     * Get processing statistics
     */
    public ProcessingStats getStats() {
        return new ProcessingStats(processedCount, validCount, invalidCount);
    }
    
    /**
     * Reset processor statistics
     */
    public void reset() {
        processedCount = 0;
        validCount = 0;
        invalidCount = 0;
    }
    
    /**
     * Processing statistics holder
     */
    public static class ProcessingStats {
        private final int processed;
        private final int valid;
        private final int invalid;
        
        public ProcessingStats(int processed, int valid, int invalid) {
            this.processed = processed;
            this.valid = valid;
            this.invalid = invalid;
        }
        
        public int getProcessed() { return processed; }
        public int getValid() { return valid; }
        public int getInvalid() { return invalid; }
        
        @Override
        public String toString() {
            return String.format("ProcessingStats{processed=%d, valid=%d, invalid=%d}", 
                               processed, valid, invalid);
        }
    }
}